name: Tinybird Branches Replacement -> New workspace when new branches to deploy are created.

on:
  create: {}

env:
  TINYBIRD_HOST: ${{ secrets.TINYBIRD_HOST }}
  TINYBIRD_TOKEN: ${{ secrets.TINYBIRD_TOKEN }}
  ORG_ID: ${{ secrets.ORG_ID }}
  TINYBIRD_USER_TOKEN: ${{ secrets.TINYBIRD_USER_TOKEN }}

jobs:
  create-workspace-and-migrate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Guard non-branch create events
        if: github.event_name == 'create'
        run: |
          if [ "${{ github.ref_type }}" != "branch" ]; then
            echo "Not a branch create event. Exiting."
            exit 78
          fi
      
      - name: Install Tinybird CLI
        run: |
          curl https://tinybird.co | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH
      
      - name: Install Tinybird CLI
        run: |
          curl https://tinybird.co | sh
          echo "$HOME/.local/bin" >> $GITHUB_PATH

      - name: Detect source workspace
        run: |
          echo "üîé Detecting current Tinybird source workspace via CLI..."
          # Capture current workspace table and extract the first data row name column
          CURRENT=$(tb --cloud \
            --host "${{ env.TINYBIRD_HOST }}" \
            --token "${{ env.TINYBIRD_TOKEN }}" \
            workspace current || true)
          # Extract the first "name: ..." value line
          NAME=$(printf "%s" "$CURRENT" | sed -n 's/^name:[[:space:]]*//p' | head -n1)

          if [ -z "$NAME" ]; then
            echo "‚ùå Could not detect current workspace name. Output was:"
            echo "$CURRENT"
            exit 1
          fi

          echo "SOURCE_WS=$NAME" >> $GITHUB_ENV

      - name: Set target workspace name 
        run: |
          NAME="${{ env.SOURCE_WS }}_${{ github.ref_name }}"
          # Replace any character not [A-Za-z0-9_] with underscore
          NAME_SANITIZED=$(printf "%s" "$NAME" | sed -E 's/[^A-Za-z0-9_]+/_/g')
          # Collapse multiple underscores and trim leading/trailing underscores
          NAME_SANITIZED=$(printf "%s" "$NAME_SANITIZED" | sed -E 's/_+/_/g; s/^_+//; s/_+$//')
          # Ensure name starts with a letter by prefixing 'name_' if needed
          case "$NAME_SANITIZED" in
            [A-Za-z]*) TARGET_WS="$NAME_SANITIZED" ;;
            *) TARGET_WS="name_$NAME_SANITIZED" ;;
          esac
          # Fallback in case sanitization produced empty string
          if [ -z "$TARGET_WS" ]; then
            TARGET_WS="name_${RANDOM}"
          fi
          echo "TARGET_WS=$TARGET_WS" >> $GITHUB_ENV

      - name: Validate inputs
        run: |
          echo "üîç Validating workflow inputs..."
          echo "Source workspace: ${{ env.SOURCE_WS }}"
          echo "Target workspace: ${{ env.TARGET_WS }}"
          echo "Copy last partition data: True by default"
          
          if [ "${{ env.SOURCE_WS }}" = "${{ env.TARGET_WS }}" ]; then
            echo "‚ùå Source and target workspaces cannot be the same"
            exit 1
          fi

      - name: Create new Tinybird workspace
        run: |
          echo "üöÄ Creating new Tinybird workspace: ${{ env.TARGET_WS }}"
          # Create new workspace using Tinybird CLI with organization context only
          tb --cloud \
            --host "${{ env.TINYBIRD_HOST }}" \
            --token "${{ env.TINYBIRD_TOKEN }}" \
            --user-token "${{ env.TINYBIRD_USER_TOKEN }}" \
            workspace create --organization-id "${{ env.ORG_ID }}" "${{ env.TARGET_WS }}" 
          
          echo "‚úÖ Workspace created successfully"
          
      - name: Deploy resources to new workspace
        run: |
          echo "üì¶ Deploying all resources to new workspace..."
          cd tinybird

          echo "Selecting the tokens to make the deployment"
          tb --cloud --user-token "${{ env.TINYBIRD_USER_TOKEN }}" workspace use "${{ env.TARGET_WS }}"
          ADMIN_TOKEN_NEW=$(tb --cloud token ls | awk '/name: admin token/{getline; print $2}')
          
          # Deploy all resources (datasources, endpoints, materializations)
          tb --cloud --host "${{ env.TINYBIRD_HOST }}" \
            --token "${{ env.ADMIN_TOKEN_NEW }}" \
            deploy --wait 
          
          echo "‚úÖ Resources deployed successfully"

      - name: Verify deployment
        run: |
          tb --cloud --user-token "${{ env.TINYBIRD_USER_TOKEN }}" workspace use "${{ env.TARGET_WS }}"
          ADMIN_TOKEN_NEW=$(tb --cloud token ls | awk '/name: admin token/{getline; print $2}')

          echo "üîç Verifying deployment in new workspace..."
          cd tinybird
          
          # List all resources in the new workspace
          echo "üìä Datasources:"
          tb --cloud --host "${{ env.TINYBIRD_HOST }}" \
            --token "${{ env.ADMIN_TOKEN_NEW }}" \
            datasource ls
          
          echo "üîó Endpoints:"
          tb --cloud --host "${{ env.TINYBIRD_HOST }}" \
            --token "${{ env.ADMIN_TOKEN_NEW }}" \
            pipe ls 
          
          echo "‚úÖ Deployment verification completed"

      - name: Export data from datasources
        run: |
          echo "üìã Copying last partition data from source to target workspace..."

          echo "Selecting the materializations to avoid copy data from them"
          datasources=()

          for file in tinybird/materializations/*.pipe; do
            if [ -f "$file" ]; then
              # Look for the line starting with DATASOURCE and get the 2nd word
              ds=$(grep -E '^DATASOURCE ' "$file" | awk '{print $2}')
              
              if [ -n "$ds" ]; then
                datasources+=("$ds")
              fi
            fi
          done
          
          # Get list of datasources from the tinybird directory
          cd tinybird/datasources
          mkdir -p fixtures
          
          for datasource_file in *.datasource; do
            if [ -f "$datasource_file" ]; then
              datasource_name=$(basename "$datasource_file" .datasource)
              if [[ ! " ${datasources[*]} " =~ " ${datasource_name} " ]]; then
                echo "üîÑ Processing datasource: $datasource_name"
                echo "Selecting partition key or date time field to export data"
                partition_key=$(awk -F'"' '/^[[:space:]]*ENGINE_PARTITION_KEY/ {print $2; exit}' "$datasource_file")

                datetime_field_key=$(grep -Eo '`[^`]+`[[:space:]]+DateTime' "$datasource_file" | head -n1 | sed -E 's/^`([^`]+)`.*/\1/')

                # If the partition key doesn't exists will check for a datetime value or will export 1M radom rows
                if [ -z "$partition_key" ]; then
                  echo "üîÑ Processing datasource: $datasource_name"

                  # It doesn't exist datetime field
                  if [ -z "$datetime_field_key" ]; then
                    # Export data from source workspace
                    tb --cloud \
                      --host "${{ env.TINYBIRD_HOST }}" \
                      --token "$TINYBIRD_TOKEN" \
                      datasource export "$datasource_name" --rows 1000000 --format ndjson
                  # It exists the date time field
                  else
                    where_clause="$datetime_field_key >= now() - INTERVAL 1 DAY"
                    tb --cloud \
                      --host "${{ env.TINYBIRD_HOST }}" \
                      --token "$TINYBIRD_TOKEN" \
                      datasource export "$datasource_name" --where "$where_clause" --rows 1000000 --format ndjson
                  fi

                # It exists partition key
                else
                  echo "Partition key: $partition_key"
                  # Selecting last partition value
                  echo "Selecting last partition value for $datasource_name"
                  # Query last partition and total rows in that partition
                  read -r last_partition_value total_rows < <(
                    tb --cloud \
                      --host "${{ env.TINYBIRD_HOST }}" \
                      --token "${{ env.TINYBIRD_TOKEN }}" \
                      sql "SELECT _partition_id, any(_part_index) AS _part_index, count() AS total
                          FROM $datasource_name
                          GROUP BY _partition_id
                          ORDER BY _part_index DESC
                          LIMIT 1" \
                    | awk '/^‚îÄ/{getline; print $1, $3; exit}'
                  )

                  echo "Last partition: $last_partition_value | Rows: $total_rows"


                  where_clause="toString($partition_key) = '$last_partition_value'"

                  # Optional: stabilize paging when you have a datetime field
                  order_by_clause=""
                  if [ -n "$datetime_field_key" ]; then
                    order_by_clause="ORDER BY $datetime_field_key"
                  fi

                  # Export data from source workspace
                  page_size=500000   # tune down if still >100MiB
                  offset=0
                  idx=0
                  while [ "$offset" -lt "$total_rows" ]; do
                    rows=$(tb --cloud --host "${{ env.TINYBIRD_HOST }}" --token "${{ env.TINYBIRD_TOKEN }}" \
                      sql "select * from $datasource_name where $where_clause $order_by_clause LIMIT $page_size OFFSET $offset" \
                      | tee "fixtures/${datasource_name}_part_${idx}.ndjson" \
                      | wc -l)
                    # subtract header if present; stop when no data
                    [ "$rows" -le 1 ] && { rm -f "fixtures/${datasource_name}_part_${idx}.ndjson"; break; }
                    offset=$((offset+page_size))
                    idx=$((idx+1))
                  done
                fi

              else
                echo "‚ö†Ô∏è Datasource $datasource_name is a materializations, skipping"
              fi
            fi
          done
          
          echo "‚úÖ Data copy process completed"


      - name: Copy data in the new workspace
        run: |
          echo "üìã Copying last partition data from source to target workspace..."

          echo "Selecting the materializations to avoid copy data from them"
          datasources=()

          for file in tinybird/materializations/*.pipe; do
            if [ -f "$file" ]; then
              # Look for the line starting with DATASOURCE and get the 2nd word
              ds=$(grep -E '^DATASOURCE ' "$file" | awk '{print $2}')
              
              if [ -n "$ds" ]; then
                datasources+=("$ds")
              fi
            fi
          done

          tb --cloud --user-token "${{ env.TINYBIRD_USER_TOKEN }}" workspace use "${{ env.TARGET_WS }}"
          ADMIN_TOKEN_NEW=$(tb --cloud token ls | awk '/name: admin token/{getline; print $2}')
          
          # Get list of datasources from the tinybird directory
          cd tinybird/datasources
          
          for datasource_file in *.datasource; do
            if [ -f "$datasource_file" ]; then
              datasource_name=$(basename "$datasource_file" .datasource)
              if [[ ! " ${datasources[*]} " =~ " ${datasource_name} " ]]; then
                echo "üîÑ Processing datasource: $datasource_name"
                
                # Import data to target workspace
                # Import data to target workspace (process all chunk files)
                shopt -s nullglob
                chunk_files=(fixtures/${datasource_name}_part_*.ndjson)

                if [ ${#chunk_files[@]} -eq 0 ]; then
                  echo "‚ö†Ô∏è No chunk files found for $datasource_name"
                else
                  echo "üì• Appending ${#chunk_files[@]} chunk(s) into $datasource_name"
                  for file in "${chunk_files[@]}"; do
                    echo "  ‚Üí ${file}"
                    tb --cloud \
                      --host "${{ env.TINYBIRD_HOST }}" \
                      --token "${{ env.ADMIN_TOKEN_NEW }}" \
                      datasource append "$datasource_name" \
                      --file "$file"
                  done
                  echo "üßπ Cleaning chunk files for $datasource_name"
                  rm -f "fixtures/${datasource_name}_part_"*.ndjson
                fi
                shopt -u nullglob
                
                # Clean up temporary directory
                rm -rf "fixtures/"
                # else
                #   echo "‚ö†Ô∏è No partitions found for datasource: $datasource_name"
                # fi
              else
                echo "‚ö†Ô∏è Datasource $datasource_name is a materializations, skipping"
              fi
            fi
          done
          
          echo "‚úÖ Data copy process completed"

      - name: Generate workspace summary
        run: |
          echo "üìä Generating workspace summary..."
          
          echo "## Workspace Creation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚úÖ New Workspace Created" >> $GITHUB_STEP_SUMMARY
          echo "- **Workspace Name**: ${{ env.TARGET_WS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Host**: ${{ env.TINYBIRD_HOST }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üì¶ Resources Deployed" >> $GITHUB_STEP_SUMMARY
          cd tinybird
          
          # Count datasources
          datasource_count=$(ls datasources/*.datasource 2>/dev/null | wc -l)
          echo "- **Datasources**: $datasource_count" >> $GITHUB_STEP_SUMMARY
          
          # Count endpoints
          endpoint_count=$(ls endpoints/*.pipe 2>/dev/null | wc -l)
          echo "- **Endpoints**: $endpoint_count" >> $GITHUB_STEP_SUMMARY
          
          # Count materializations
          materialization_count=$(ls materializations/*.pipe 2>/dev/null | wc -l)
          echo "- **Materializations**: $materialization_count" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          
          echo "### üìã Data Migration" >> $GITHUB_STEP_SUMMARY
          echo "- **Source Workspace**: ${{ github.event.inputs.source_workspace }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Data Copied**: Last partition from each datasource" >> $GITHUB_STEP_SUMMARY
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üîó Next Steps" >> $GITHUB_STEP_SUMMARY
          echo "1. Verify the new workspace in Tinybird dashboard" >> $GITHUB_STEP_SUMMARY
          echo "2. Update any configuration files that reference the workspace" >> $GITHUB_STEP_SUMMARY
          echo "3. Test endpoints and materializations" >> $GITHUB_STEP_SUMMARY

      - name: Cleanup (if workspace creation fails)
        if: failure()
        run: |
          echo "üßπ Cleaning up on failure..."
          
          # Only attempt cleanup if we have the target token
          if [ -n "$TINYBIRD_USER_TOKEN" ]; then
            echo "üóëÔ∏è Attempting to delete workspace: ${{ env.TARGET_WS }}"
            tb --cloud \
              --host "${{ env.TINYBIRD_HOST }}" \
              --token "$TINYBIRD_USER_TOKEN" \
              workspace delete "${{ env.TARGET_WS }}" --yes || echo "‚ö†Ô∏è Could not delete workspace (may not exist)"
          fi 